# Type level programming in Fωμ

# Fωμ does not have kind polymorphism.  However, in this variant of Fωμ there is
# kind inference and type definitions are roughly treated as templates to be
# instantiated at every use.  This combination gives a kind of ML-style or
# Let-polymorphism at the kind level.

# Pairs

type Pair = λl.λr.λf.f l r in

type Fst = λp.p (λl.λ_.l) in
type Snd = λp.p (λ_.λr.r) in

type Cross = λf.λg.λp.
  type l = f (Fst p) in
  type r = g (Snd p) in
  Pair l r in

# Booleans

type T = λt.λ_.t in
type F = λ_.λf.f in

type Not = λb.λt.λf.b f t in

type And = λl.λr.λt.λf.l (r t f) f in
type Or  = λl.λr.λt.λf.l t (r t f) in

# Natural numbers

type Succ = λn.λs.λz.s (n s z) in

type N0 = λ_.λz.z in
type N1 = Succ N0 in
type N2 = Succ N1 in
type N3 = Succ N2 in

# Lists

type Nil = λn.λc.n in
type Cons = λh.λt.λn.λc.c h (t n c) in

type Map = λf.λxs.λn.λc.xs n (λx.c (f x)) in

#

λ_:Map (λt.(t,t)) (Cons int (Cons string (Cons bool Nil))) () (λh.λt.(h, t)).()

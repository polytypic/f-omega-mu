# Types of lists of various lengths

# An ordinary recursive list type
type Œºlist_of_0_to_n = ŒªŒ±.'Nil | 'Cons (Œ±, list_of_0_to_n Œ±) in

# A list of exactly one element
type  list_of_1      = ŒªŒ±.'Cons (Œ±, 'Nil) in

# A list of one or more elements
type  list_of_1_to_n = ŒªŒ±.'Cons (Œ±, list_of_0_to_n Œ±) in

# An infinite list (due to strictness these are always cycles)
type Œºlist_of_inf    = ŒªŒ±.'Cons (Œ±, list_of_inf Œ±) in

# We now have the following subtype relationships:
#
#   list_of_1_to_n Œ±  ‚äÇ  list_of_0_to_n Œ±
#      list_of_inf Œ±  ‚äÇ  list_of_1_to_n Œ±
#        list_of_1 Œ±  ‚äÇ  list_of_1_to_n Œ±
#
# Or as a hierarhy:
#
#             list_of_0_to_n Œ±
#                     |
#             list_of_1_to_n Œ±
#                    / \
#         list_of_1 Œ±   list_of_inf Œ±
#
# Moreover, lists of any finite length or more can be similarly specified
# yielding the expected subtype relationships.

let an_empty_list     : list_of_0_to_n int = 'Nil in
let a_singleton_list  : list_of_1      int = 'Cons (2, 'Nil) in
let a_non_empty_list  : list_of_1_to_n int = 'Cons (101, 'Nil) in
let Œºan_infinite_list : list_of_inf    int = 'Cons (42, an_infinite_list) in

# Type safe function to get the first element of a non-empty list:
let head = ŒõŒ±.case { Cons = Œª(x:Œ±, _:list_of_0_to_n Œ±).x } in

let _ = head[int] an_infinite_list in
let _ = head[int] a_non_empty_list in
let _ = head[int] ‚óÅ 'Cons (4, an_empty_list) in

# Extract the only element of a one element list:
let only = ŒõŒ±.case { Cons = Œª(x: Œ±, _:'Nil).x } in

let _ = only[int] a_singleton_list in

# The type of `cycle` guarantees that it returns an infinite list:
let cycle = ŒõŒ±.Œªxxs:list_of_1_to_n Œ±.
  Œºcycle:list_of_inf Œ±.
    let Œºcomplete:list_of_0_to_n Œ± ‚Üí list_of_inf Œ± = Œªxs:list_of_0_to_n Œ±.
      # Equality is work-in-progress ü§´
      if xxs =[list_of_0_to_n Œ±] xs then
        cycle
      else
        xs ‚ñ∑ case {
          Nil = Œª().cycle,
          Cons = Œª(x:Œ±, xs:list_of_0_to_n Œ±).'Cons (x, complete xs)
        } in
    xxs ‚ñ∑ case { Cons = Œª(x:Œ±, xs:list_of_0_to_n Œ±).'Cons (x, complete xs) } in

cycle[int] ‚óÅ 'Cons (4, a_singleton_list)
‚ñ∑ cycle[int]

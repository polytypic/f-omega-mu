# Types of lists of various lengths

# This example explores the idea that with equirecursive structural types it is
# possible to encode some properties of the length of a list, such as that a
# list is non-empty, without using number parameterized types.

# An ordinary recursive list type
type Œºlist_of_0_to_n = ŒªŒ±.'Nil | 'Cons (Œ±, list_of_0_to_n Œ±)

# A list of exactly one element
type  list_of_1      = ŒªŒ±.'Cons (Œ±, 'Nil)

# A list of one or more elements
type  list_of_1_to_n = ŒªŒ±.'Cons (Œ±, list_of_0_to_n Œ±)

# An infinite list (due to strictness these are always cycles)
type Œºlist_of_inf    = ŒªŒ±.'Cons (Œ±, list_of_inf Œ±)

# We now have the following subtype relationships:
#
#   list_of_1_to_n Œ±  ‚äÇ  list_of_0_to_n Œ±
#      list_of_inf Œ±  ‚äÇ  list_of_1_to_n Œ±
#        list_of_1 Œ±  ‚äÇ  list_of_1_to_n Œ±
#
# Or as a hierarhy:
#
#             list_of_0_to_n Œ±
#                     |
#             list_of_1_to_n Œ±
#                    / \
#         list_of_1 Œ±   list_of_inf Œ±
#
# Moreover, lists of any finite length or more can be similarly specified
# yielding the expected subtype relationships.

let an_empty_list     : list_of_0_to_n int = 'Nil
let a_singleton_list  : list_of_1      int = 'Cons (2, 'Nil)
let a_non_empty_list  : list_of_1_to_n int = 'Cons (101, 'Nil)
let Œºan_infinite_list : list_of_inf    int = 'Cons (42, an_infinite_list)

# Type safe function to get the first element of a non-empty list:
let head: ‚àÄŒ±.list_of_1_to_n Œ± ‚Üí Œ± = Œõ_.case { Cons = Œª(x, _).x }

let _ = head[int] an_infinite_list
let _ = head[int] a_non_empty_list
let _ = head[int] ‚óÅ 'Cons (4, an_empty_list)

# Extract the only element of a one element list:
let only: ‚àÄŒ±.list_of_1 Œ± ‚Üí Œ± = Œõ_.case { Cons = Œª(x, _).x }

let _ = only[int] a_singleton_list

# The type of `cycle` guarantees that it returns an infinite list:
let cycle: ‚àÄŒ±.list_of_1_to_n Œ± ‚Üí list_of_inf Œ± = ŒõŒ±.Œªxxs.
  Œºcycle.
    let Œºcomplete: list_of_0_to_n Œ± ‚Üí list_of_inf Œ± = Œªxs.
      # Equality is work-in-progress ü§´
      if xxs =[list_of_0_to_n Œ±] xs then
        cycle
      else
        xs ‚ñ∑ case {
          Nil = Œª().cycle
          Cons = Œª(x, xs).'Cons (x, complete xs)
        }
    xxs ‚ñ∑ case { Cons = Œª(x, xs).'Cons (x, complete xs) }

cycle[int] ‚óÅ 'Cons (4, a_singleton_list)
‚ñ∑ cycle[int]

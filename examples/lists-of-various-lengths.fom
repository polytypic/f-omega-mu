# Types of lists of various lengths

# An ordinary recursive list type
let type Î¼list_of_0_to_n = Î»Î±.[nil: (), cons: (Î±, list_of_0_to_n Î±)] in

# A list of exactly one element
let type  list_of_1      = Î»Î±.[cons: (Î±, [nil: ()])] in

# A list of one or more elements
let type  list_of_1_to_n = Î»Î±.[cons: (Î±, list_of_0_to_n Î±)] in

# An infinite list (due to strictness these are always cycles)
let type Î¼list_of_inf    = Î»Î±.[cons: (Î±, list_of_inf Î±)] in

# We now have the following subtype relationships:
#
#   list_of_1_to_n Î±  âŠ‚  list_of_0_to_n Î±
#      list_of_inf Î±  âŠ‚  list_of_1_to_n Î±
#        list_of_1 Î±  âŠ‚  list_of_1_to_n Î±
#
# Or as a hierarhy:
#
#             list_of_0_to_n Î±
#                     |
#             list_of_1_to_n Î±
#                    / \
#         list_of_1 Î±   list_of_inf Î±
#
# Moreover, lists of any finite length or more can be similarly specified
# yielding the expected subtype relationships.

let an_empty_list     : list_of_0_to_n int = [nil = ()] in
let a_singleton_list  : list_of_1      int = [cons = (2, [nil = ()])] in
let a_non_empty_list  : list_of_1_to_n int = [cons = (101, [nil = ()])] in
let Î¼an_infinite_list : list_of_inf    int = [cons = (42, an_infinite_list)] in

# Type safe function to get the first element of a non-empty list:
let head = Î›Î±.case { cons = Î»(x:Î±, _:list_of_0_to_n Î±).x } in

let _ = head[int] an_infinite_list in
let _ = head[int] a_non_empty_list in
let _ = head[int] [cons = (4, an_empty_list)] in

# Extract the only element of a one element list:
let only = Î›Î±.case { cons = Î»(x: Î±, _:[nil: ()]).x } in

let _ = only[int] a_singleton_list in

# The type of `cycle` guarantees that it returns an infinite list:
let cycle = Î›Î±.Î»xxs:list_of_1_to_n Î±.
  Î¼cycle:list_of_inf Î±.
    let Î¼complete:list_of_0_to_n Î± â†’ list_of_inf Î± = Î»xs:list_of_0_to_n Î±.
      # Equality is work-in-progress ðŸ¤«
      if xxs =[list_of_0_to_n Î±] xs then
        cycle
      else
        xs â–· case {
          nil = Î»().cycle,
          cons = Î»(x:Î±, xs:list_of_0_to_n Î±).[cons = (x, complete xs)]
        } in
    xxs â–· case { cons = Î»(x:Î±, xs:list_of_0_to_n Î±).[cons = (x, complete xs)] } in

cycle[int] [cons = (4, a_singleton_list)]
â–· cycle[int]

# Types of lists of various lengths

# This example explores the idea that with equirecursive structural types it is
# possible to encode some properties of the length of a list, such as that a
# list is non-empty, without using number parameterized types.

# An ordinary recursive list type
type Î¼list_of_0_to_n = Î»Î±.'Nil | 'Cons (Î±, list_of_0_to_n Î±)

# A list of exactly one element
type  list_of_1      = Î»Î±.'Cons (Î±, 'Nil)

# A list of one or more elements
type  list_of_1_to_n = Î»Î±.'Cons (Î±, list_of_0_to_n Î±)

# An infinite list (due to strictness these are always cycles)
type Î¼list_of_inf    = Î»Î±.'Cons (Î±, list_of_inf Î±)

# We now have the following subtype relationships:
#
#   list_of_1_to_n Î±  âŠ‚  list_of_0_to_n Î±
#      list_of_inf Î±  âŠ‚  list_of_1_to_n Î±
#        list_of_1 Î±  âŠ‚  list_of_1_to_n Î±
#
# Or as a hierarhy:
#
#             list_of_0_to_n Î±
#                     |
#             list_of_1_to_n Î±
#                    / \
#         list_of_1 Î±   list_of_inf Î±
#
# Moreover, lists of any finite length or more can be similarly specified
# yielding the expected subtype relationships.

let an_empty_list     : list_of_0_to_n int = 'Nil
let a_singleton_list  : list_of_1      int = 'Cons (2, 'Nil)
let a_non_empty_list  : list_of_1_to_n int = 'Cons (101, 'Nil)
let Î¼an_infinite_list : list_of_inf    int = 'Cons (42, an_infinite_list)

# Type safe function to get the first element of a non-empty list:
let head: âˆ€Î±.list_of_1_to_n Î± â†’ Î± = Î›_.case { Cons = Î»(x, _).x }

let _ = headÂ«intÂ» an_infinite_list
let _ = headÂ«intÂ» a_non_empty_list
let _ = headÂ«intÂ» â— 'Cons (4, an_empty_list)

# Extract the only element of a one element list:
let only: âˆ€Î±.list_of_1 Î± â†’ Î± = Î›_.case { Cons = Î»(x, _).x }

let _ = onlyÂ«intÂ» a_singleton_list

# The type of `cycle` guarantees that it returns an infinite list:
let cycle: âˆ€Î±.list_of_1_to_n Î± â†’ list_of_inf Î± = Î›Î±.Î»xxs.
  Î¼cycle.
    let Î¼complete: list_of_0_to_n Î± â†’ list_of_inf Î± = Î»xs.
      # Equality is work-in-progress ğŸ¤«
      if xxs =Â«list_of_0_to_n Î±Â» xs then
        cycle
      else
        xs â–· case {
          Nil = Î»().cycle
          Cons = Î»(x, xs).'Cons (x, complete xs)
        }
    xxs â–· case { Cons = Î»(x, xs).'Cons (x, complete xs) }

cycleÂ«intÂ» â— 'Cons (4, a_singleton_list)
â–· cycleÂ«intÂ»

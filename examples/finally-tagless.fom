# Finally Tagless

# This example is inspired by the paper:
#
#   Finally Tagless, Partially Evaluated:
#     Tagless Staged Interpreters for Simpler Typed Languages
#   by Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan
#   https://okmij.org/ftp/tagless-final/index.html
#
# This example differs from the paper mainly in that the interpreter is built
# compositionally.  Also, the whole evaluation semantics is thunked so there is
# no need to treat conditionals as a special case.

# Types for the two semantics (evaluation â„° and size ğ’®)

type â„° = Î»Î±.() â†’ Î±
type ğ’® = Î»_.int

# Integer expressions

type IntExp = Î»Ïƒ.{
  Int: int â†’ Ïƒ int
  Add: Ïƒ int â†’ Ïƒ int â†’ Ïƒ int
  Mul: Ïƒ int â†’ Ïƒ int â†’ Ïƒ int
  Leq: Ïƒ int â†’ Ïƒ int â†’ Ïƒ bool
}

let IntExp =
  let eval: IntExp â„° = {
    Int = Î»i.Î»().i
    Add = Î»x.Î»y.Î»().x() + y()
    Mul = Î»x.Î»y.Î»().x() * y()
    Leq = Î»x.Î»y.Î»().x() â‰¤ y()
  }
  let size: IntExp ğ’® = {
    Int = Î»_.1
    Add = Î»x.Î»y.x + y + 1
    Mul = Î»x.Î»y.x + y + 1
    Leq = Î»x.Î»y.x + y + 1
  }
  {eval, size}

# Boolean expressions

type BoolExp = Î»Ïƒ.{
  Bool: bool â†’ Ïƒ bool
  If: âˆ€Î±.Ïƒ bool â†’ Ïƒ Î± â†’ Ïƒ Î± â†’ Ïƒ Î±
}

let BoolExp =
  let eval: BoolExp â„° = {
    Bool = Î»b.Î»().b
    If = Î›_.Î»c.Î»t.Î»e.Î»().if c() then t() else e()
  }
  let size: BoolExp ğ’® = {
    Bool = Î»_.1
    If = Î›_.Î»c.Î»t.Î»e.c + t + e + 1
  }
  {eval, size}

# Lambda expressions

type LamExp = Î»Ïƒ.{
  Lam: âˆ€Î±.âˆ€Î².(Ïƒ Î± â†’ Ïƒ Î²) â†’ Ïƒ (Î± â†’ Î²)
  App: âˆ€Î±.âˆ€Î².Ïƒ (Î± â†’ Î²) â†’ Ïƒ Î± â†’ Ïƒ Î²
}

let LamExp =
  let eval: LamExp â„° = {
    Lam = Î›_.Î›_.Î»f.Î»().Î»x.f (Î»().x) (),
    App = Î›_.Î›_.Î»f.Î»x.Î»().f() x()
  }
  let size: LamExp ğ’® = {
    Lam = Î›_.Î›_.Î»f.f 0 + 1
    App = Î›_.Î›_.Î»f.Î»x.f + x + 1
  }
  {eval, size}

# Fixpoint expression

type FixExp = Î»Ïƒ.{Fix: âˆ€Î±.(Ïƒ Î± â†’ Ïƒ Î±) â†’ Ïƒ Î±}

let FixExp =
  let eval: FixExp â„° = {Fix = Î›_.Î»f.Î»().Î¼x.f (Î»().x) ()}
  let size: FixExp ğ’® = {Fix = Î›_.Î»f.f 0 + 1}
  {eval, size}

# Composition of interpreter

type Exp = IntExp âˆ§ BoolExp âˆ§ LamExp âˆ§ FixExp

let Exp = IntExp â€ BoolExp â€ LamExp â€ FixExp

# An example

let pow_exp = Î›Ïƒ.Î»S: Exp Ïƒ.
  S.Lam[int][int â†’ int] Î»x.S.Fix[int â†’ int] Î»pow.
    S.Lam[int][int] Î»n.
      S.If[int] S.Leq(n)(S.Int(0))
        S.Int(1)
        S.Mul(x)(S.App[int][int] pow â— S.Add n S.Int(-1))

let pow = pow_exp[â„°] Exp.eval ()
let pow_size = pow_exp[ğ’®] Exp.size

# The FÏ‰Î¼ toy compiler can constant fold the size calculation and completely
# eliminate the thunking of the evaluation semantics.

pow 2 pow_size

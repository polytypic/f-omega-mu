# Finally Tagless

# This example is inspired by the paper:
#
#   Finally Tagless, Partially Evaluated:
#     Tagless Staged Interpreters for Simpler Typed Languages
#   by Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan
#   https://okmij.org/ftp/tagless-final/index.html
#
# This example differs from the paper mainly in that the interpreter is built
# compositionally.  Also, the whole evaluation semantics is thunked so there is
# no need to treat conditionals as a special case.

# Types for the two semantics (evaluation â„° and size ğ’®)

type â„° = Î»Î±.() â†’ Î±
type ğ’® = Î»_.int

# Integer expressions

type IntExp = Î»Ïƒ.{
  Int: int â†’ Ïƒ int
  Add: Ïƒ int â†’ Ïƒ int â†’ Ïƒ int
  Mul: Ïƒ int â†’ Ïƒ int â†’ Ïƒ int
  Leq: Ïƒ int â†’ Ïƒ int â†’ Ïƒ bool
}

let IntExp =
  let bop = Î›Î±.Î›Î².Î»op: Î± â†’ Î± â†’ Î².Î»l: â„° Î±.Î»r: â„° Î±.Î»().op l() r()
  let eval: IntExp â„° = {
    Int = Î»i: int.Î»().i,
    Add = bop[int][int] (+),
    Mul = bop[int][int] (*),
    Leq = bop[int][bool] (â‰¤)
  }
  let size: IntExp ğ’® = {
    Int = Î»_: int.1
    Add = Î»x: ğ’® int.Î»y: ğ’® int.x + y + 1
    Mul = Î»x: ğ’® int.Î»y: ğ’® int.x + y + 1
    Leq = Î»x: ğ’® int.Î»y: ğ’® int.x + y + 1
  }
  {eval, size}

# Boolean expressions

type BoolExp = Î»Ïƒ.{
  Bool: bool â†’ Ïƒ bool
  If: âˆ€Î±.Ïƒ bool â†’ Ïƒ Î± â†’ Ïƒ Î± â†’ Ïƒ Î±
}

let BoolExp =
  let eval: BoolExp â„° = {
    Bool = Î»b: bool.Î»().b
    If = Î›Î±.Î»c: â„° bool.Î»t: â„° Î±.Î»e: â„° Î±.Î»().if c() then t() else e()
  }
  let size: BoolExp ğ’® = {
    Bool = Î»_: bool.1
    If = Î›Î±.Î»c: ğ’® bool.Î»t: ğ’® Î±.Î»e: ğ’® Î±.c + t + e + 1
  }
  {eval, size}

# Lambda expressions

type LamExp = Î»Ïƒ.{
  Lam: âˆ€Î±.âˆ€Î².(Ïƒ Î± â†’ Ïƒ Î²) â†’ Ïƒ (Î± â†’ Î²)
  App: âˆ€Î±.âˆ€Î².Ïƒ (Î± â†’ Î²) â†’ Ïƒ Î± â†’ Ïƒ Î²
}

let LamExp =
  let eval: LamExp â„° = {
    Lam = Î›Î±.Î›Î².Î»f: â„° Î± â†’ â„° Î².Î»().Î»x: Î±.f (Î»().x) (),
    App = Î›Î±.Î›Î².Î»f: â„° (Î± â†’ Î²).Î»x: â„° Î±.Î»().f() x()
  }
  let size: LamExp ğ’® = {
    Lam = Î›Î±.Î›Î².Î»f: ğ’® Î± â†’ ğ’® Î².f 0 + 1
    App = Î›Î±.Î›Î².Î»f: ğ’® (Î± â†’ Î²).Î»x: ğ’® Î±.f + x + 1
  }
  {eval, size}

# Fixpoint expression

type FixExp = Î»Ïƒ.{Fix: âˆ€Î±.(Ïƒ Î± â†’ Ïƒ Î±) â†’ Ïƒ Î±}

let FixExp =
  let eval: FixExp â„° = {Fix = Î›Î±.Î»f: â„° Î± â†’ â„° Î±.Î»().Î¼x: Î±.f (Î»().x) ()}
  let size: FixExp ğ’® = {Fix = Î›Î±.Î»f: ğ’® Î± â†’ ğ’® Î±.f 0 + 1}
  {eval, size}

# Composition of interpreter

type Exp = IntExp âˆ§ BoolExp âˆ§ LamExp âˆ§ FixExp

let Exp = IntExp â€ BoolExp â€ LamExp â€ FixExp

# An example

let pow_exp = Î›Ïƒ.Î»S: Exp Ïƒ.
  S.Lam[int][int â†’ int] Î»x: Ïƒ int.S.Fix[int â†’ int] Î»pow: Ïƒ (int â†’ int).
    S.Lam[int][int] Î»n: Ïƒ int.
      S.If[int] S.Leq(n)(S.Int(0))
        S.Int(1)
        S.Mul(x)(S.App[int][int] pow â— S.Add n S.Int(-1))

let pow = pow_exp[â„°] Exp.eval ()
let pow_size = pow_exp[ğ’®] Exp.size

# The FÏ‰Î¼ toy compiler can constant fold the size calculation and completely
# eliminate the thunking of the evaluation semantics.

pow 2 pow_size

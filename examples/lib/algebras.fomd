local include "types"

# *

type Equals = Î»Ï„.{
  equals: Ï„ â†’ Ï„ â†’ bool
}

type Less = Î»Ï„.{
  less: Ï„ â†’ Ï„ â†’ bool
}

type Compare = Î»Ï„.{
  compare: Ï„ â†’ Ï„ â†’ ord
}

type Concat = Î»Ï„.{
  concat: Ï„ â†’ Ï„ â†’ Ï„
}

type Empty = Î»Ï„.{
  empty: Ï„
}

type Invert = Î»Ï„.{
  invert: Ï„ â†’ Ï„
}

type Monoid = Empty âˆ§ Concat

type Group = Monoid âˆ§ Invert

# * â†’ *

type Zero = Î»ğ¹.{
  zero: âˆ€Î±.ğ¹ Î±
}

type Of = Î»ğ¹.{
  of: âˆ€Î±.Î± â†’ ğ¹ Î±
}

type Filter = Î»ğ¹.{
  filter: âˆ€Î±.(Î± â†’ bool) â†’ ğ¹ Î± â†’ ğ¹ Î±
}

type Map = Î»ğ¹.{
  map: âˆ€Î±.âˆ€Î².(Î± â†’ Î²) â†’ ğ¹ Î± â†’ ğ¹ Î²
}

type Functor = Map

type Ap = Î»ğ¹.{
  ap: âˆ€Î±.âˆ€Î².ğ¹ (Î± â†’ Î²) â†’ ğ¹ Î± â†’ ğ¹ Î²
}

type Applicative = Of âˆ§ Ap

type Plus = Î»ğ¹.{
  plus: âˆ€Î±.ğ¹ Î± â†’ ğ¹ Î± â†’ ğ¹ Î±
}

type Reduce = Î»ğ¹.{
  reduce: âˆ€Î±.âˆ€Î².(Î± â†’ Î² â†’ Î±) â†’ Î± â†’ ğ¹ Î² â†’ Î±
}

type Extend = Î»ğ¹.{
  extend: âˆ€Î±.âˆ€Î².(ğ¹ Î± â†’ Î²) â†’ ğ¹ Î± â†’ ğ¹ Î²
}

type Extract = Î»ğ¹.{
  extract: âˆ€Î±.ğ¹ Î± â†’ Î±
}

type Comonad = Extend âˆ§ Extract

type Contramap = Î»ğ¹.{
  contramap: âˆ€Î±.âˆ€Î².(Î± â†’ Î²) â†’ ğ¹ Î² â†’ ğ¹ Î±
}

type Traverse = Î»ğ‘‡.{
  traverse: âˆ€ğ¹.Applicative ğ¹ â†’ âˆ€Î±.âˆ€Î².(Î± â†’ ğ¹ Î²) â†’ ğ‘‡ Î± â†’ ğ¹ (ğ‘‡ Î²)
}

type Chain = Î»ğ¹.{
  chain: âˆ€Î±.âˆ€Î².(Î± â†’ ğ¹ Î²) â†’ ğ¹ Î± â†’ ğ¹ Î²
}

type Monad = Of âˆ§ Chain

type Traversable = Traverse

# * â†’ * â†’ *

type Id = Î»ğ¹.{
  id: âˆ€Î±.âˆ€Î².ğ¹ Î± Î²
}

type Compose = Î»ğ¹.{
  compose: âˆ€Î±.âˆ€Î².âˆ€Î³.ğ¹ Î± Î² â†’ ğ¹ Î² Î³ â†’ ğ¹ Î± Î³
}

type Category = Id âˆ§ Compose

type Bimap = Î»ğ¹.{
  bimap: âˆ€Î±.âˆ€Î².âˆ€Î³.âˆ€Î´.(Î± â†’ Î²) â†’ (Î³ â†’ Î´) â†’ ğ¹ Î± Î³ â†’ ğ¹ Î² Î´
}

type Promap = Î»ğ¹.{
  promap: âˆ€Î±.âˆ€Î².âˆ€Î³.âˆ€Î´.(Î± â†’ Î²) â†’ (Î³ â†’ Î´) â†’ ğ¹ Î² Î³ â†’ ğ¹ Î± Î´
}

type Profunctor = Promap

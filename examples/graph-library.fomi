∀monad:* → *.∀map:* → *.∀graph.∀vertex.∀edge.
  {of: ∀α.α → monad α, chain: ∀α.∀β.(α → monad β) → monad α → monad β} →
  {
    count: ∀ν.map ν → int
    empty: ∀(map)
    entries: ∀ν.map ν → (μlist:* → *.λα.'Nil | 'Cons (α, list α)) (vertex, ν)
    get: ∀ν.map ν → vertex → 'None | 'Some ν
    put: ∀ν.vertex → ν → map ν → map ν
    fold_back: ∀ρ.∀ν.((vertex, ν) → ρ → ρ) → ρ → map ν → ρ
  } →
  {
    out_edges:
      graph →
      vertex →
      | 'None
      | 'Some ((μlist:* → *.λα.'Nil | 'Cons (α, list α)) edge)
    source: graph → edge → vertex
    sink: graph → edge → vertex
    vertices: graph → (μlist:* → *.λα.'Nil | 'Cons (α, list α)) vertex
    num_vertices: graph → int
  } →
  {
    discover_vertex: graph → vertex → monad ()
    finish_vertex: graph → vertex → monad ()
    examine_edge: graph → edge → monad ()
    tree_edge: graph → edge → monad ()
    non_tree_edge: graph → edge → monad ()
    gray_target: graph → edge → monad ()
    black_target: graph → edge → monad ()
  } →
  graph →
  vertex →
  monad ()

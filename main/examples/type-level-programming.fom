# Type level programming in F渭

# F渭 does not have kind polymorphism.  However, in this variant of F渭 there is
# kind inference and type definitions are roughly treated as templates to be
# instantiated at every use.  This combination gives a kind of ML-style or
# Let-polymorphism at the kind level.

# Pairs

type Pair = 位l.位r.位f.f l r

type Fst = 位p.p 位l.位_.l
type Snd = 位p.p 位_.位r.r

type Cross = 位f.位g.位p.
  type l = f (Fst p)
  type r = g (Snd p)
  Pair l r

# Booleans

type T = 位t.位_.t
type F = 位_.位f.f

type Not = 位b.位t.位f.b f t

type And = 位l.位r.位t.位f.l (r t f) f
type Or  = 位l.位r.位t.位f.l t (r t f)

# Natural numbers

type Succ = 位n.位s.位z.s (n s z)

type  = 位_.位z.z
type  = Succ 
type  = Succ 
type  = Succ 

# Lists

type Nil = 位n.位_.n
type Cons = 位h.位t.位n.位c.c h (t n c)

type Map = 位f.位xs.位n.位c.xs n 位x.c (f x)

#

位_: Map 位t.(t, t)
        (Cons int (Cons string (Cons bool Nil)))
        ()
        位h.位t.(h, t).()

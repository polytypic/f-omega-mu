# Finally Tagless

# This example is inspired by the paper:
#
#   Finally Tagless, Partially Evaluated:
#     Tagless Staged Interpreters for Simpler Typed Languages
#   by Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan
#   https://okmij.org/ftp/tagless-final/index.html
#
# This example differs from the paper mainly in that the interpreter is built
# compositionally.  Also, the whole evaluation semantics is thunked so there is
# no need to treat conditionals as a special case.

# Types for the two semantics (evaluation â„° and size ğ’®)

type â„° = Î»Î±.() â†’ Î±
type ğ’® = Î»_.int

type Î£ = Î»ğ¹.{eval: ğ¹ â„°, size: ğ¹ ğ’®}

# Integer expressions

type IntExp = Î»Ïƒ.{
  Int: int â†’ Ïƒ int
  Add: Ïƒ int â†’ Ïƒ int â†’ Ïƒ int
  Mul: Ïƒ int â†’ Ïƒ int â†’ Ïƒ int
  Leq: Ïƒ int â†’ Ïƒ int â†’ Ïƒ bool
}

let IntExp: Î£ IntExp = {
  eval = {
    Int = Î»i.Î»().i
    Add = Î»x.Î»y.Î»().x() + y()
    Mul = Î»x.Î»y.Î»().x() * y()
    Leq = Î»x.Î»y.Î»().x() â‰¤ y()
  }
  size = {
    Int = Î»_.1
    Add = Î»x.Î»y.x + y + 1
    Mul = Î»x.Î»y.x + y + 1
    Leq = Î»x.Î»y.x + y + 1
  }
}

# Boolean expressions

type BoolExp = Î»Ïƒ.{
  Bool: bool â†’ Ïƒ bool
  If: âˆ€Î±.Ïƒ bool â†’ Ïƒ Î± â†’ Ïƒ Î± â†’ Ïƒ Î±
}

let BoolExp: Î£ BoolExp = {
  eval = {
    Bool = Î»b.Î»().b
    If = Î»c.Î»t.Î»e.Î»().if c() then t() else e()
  }
  size = {
    Bool = Î»_.1
    If = Î»c.Î»t.Î»e.c + t + e + 1
  }
}

# Lambda expressions

type LamExp = Î»Ïƒ.{
  Lam: âˆ€Î±.âˆ€Î².(Ïƒ Î± â†’ Ïƒ Î²) â†’ Ïƒ (Î± â†’ Î²)
  App: âˆ€Î±.âˆ€Î².Ïƒ (Î± â†’ Î²) â†’ Ïƒ Î± â†’ Ïƒ Î²
}

let LamExp: Î£ LamExp = {
  eval = {
    Lam = Î»f.Î»().Î»x.f (Î»().x) ()
    App = Î»f.Î»x.Î»().f() x()
  }
  size = {
    Lam = Î»f.f 0 + 1
    App = Î»f.Î»x.f + x + 1
  }
}

# Fixpoint expression

type FixExp = Î»Ïƒ.{Fix: âˆ€Î±.(Ïƒ Î± â†’ Ïƒ Î±) â†’ Ïƒ Î±}

let FixExp: Î£ FixExp = {
  eval = {Fix = Î»f.Î»().Î¼x.f (Î»().x) ()}
  size = {Fix = Î»f.f 0 + 1}
}

# Composition of interpreter

type Exp = IntExp âˆ§ BoolExp âˆ§ LamExp âˆ§ FixExp

let Exp = IntExp â€ BoolExp â€ LamExp â€ FixExp

# An example

let pow_exp = Î›Ïƒ.Î»S: Exp Ïƒ.
  S.LamÂ«intÂ»Â«int â†’ intÂ» Î»x.S.FixÂ«int â†’ intÂ» Î»pow.
    S.LamÂ«intÂ»Â«intÂ» Î»n.
      S.IfÂ«intÂ» S.Leq(n)(S.Int(0))
        S.Int(1)
        S.Mul(x)(S.AppÂ«intÂ»Â«intÂ» pow â— S.Add n S.Int(-1))

let pow = pow_expÂ«â„°Â» Exp.eval ()
let pow_size = pow_expÂ«ğ’®Â» Exp.size

# The FÏ‰Î¼ toy compiler can constant fold the size calculation and completely
# eliminate the thunking of the evaluation semantics.

pow 2 pow_size
